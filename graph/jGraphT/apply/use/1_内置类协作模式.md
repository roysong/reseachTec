# 内置类协作模式  
## 内置类分类  
JGraphT中的大部分实现类都能够归属到以下的类别中：  
* 核心数据结构：特定类型图形内容的内存表示（比如，DefaultDirectedGraph，WeightedMultiGraph）  
* 视图数据结构：基于其它图用来提供“视图”的类（比如，可以基于任意有向图来生成一个EdgeReversedGraph，用于模拟一张已存在图的连线反向图）  
* 迭代器：标准图迭代器（比如，DepthFirstIterator，ClosestFirstIterator）  
* 图形分析算法：从图中查询某些属性或提取某种结构的算法（比如：DijkstraShortestPath）  
* 图形生成器和转化器：用于创建或更新图的算法（比如，RingGraphGenerator）  
* 索引算法：计算和存储图、连线和顶点的某些属性以便快速检索（比如：NeighborIndex）  
* 扩展器：用于和其它图形工具进行交互的工具类（比如，JGraphModelAdapter，MatrixExporter）  
* 工具类：常用的工具方法集  

基于以上概念，下面的章节将会解释常见的一些协作模式。  
## 如果能通过视图达成的，就不要去修改任何迭代器或算法  
举个例子，我们已经有AsUndirectedGraph和EdgeReversedGraph视图，前一个能够让你将一张有向图转换为无向图。所以，如果你有一个有向树结构的图，却想要忽略其方向进行广度优先查询时，只需基于原图创建一个AsUndirectedGraph对象，然后将它作为BreadthFirstIterator的参数即可。同样地，如果你有一张有向无环图并想要在其上执行一次反向拓扑逻辑排序，基于原图生成一个EdgeReversedGraph实例，然后将它作为参数传递给TopologicalOrderIterator即可。  
为什么要这么做呢？  
* 职责单一。与其让迭代器中支持多种图形的查询逻辑，不如让这些结构以视图方式单独呈现，以保持代码的可读性。  
* 能够重用。一旦某视图类开发完成，就可以重用它来增强所有已存的及未来的迭代器。  

## 保持接口最小化  
如果你总是想修改核心的图形接口和数据结构来增加一些方法比如isConnected（两个顶点是否连接的判断方法）。强烈不建议这么做，为什么呢？  
* 核心及视图的实现已经很复杂了；从维护的角度来看，每一个增加的方法都会伤筋动骨并带来一堆潜在的Bug（比如说，错误的覆写方法或者委托方法）。  
* 每个增加的方法同样会对新图形实现的开发增加负担。比如说，假设有人根据关系性数据库的表实现了一个图形的后台。这个实现可能没有继承任何核心数据结构，所以当你在错误的基类中增加一个便利性方法比如isConnected，它就不会在关系型数据库的图形实现上生效。而且并非每次都能很容易找出某个方法应该属于哪个继承体系或者哪个委托模式中。那么这种情况我们应该怎么办呢？我们应该为感兴趣的属性抽取出一个新的分析算法或者工具类方法来（比如，ConnectivityInspector）。如果你担心重新计算的性能消耗，那就创建一个带索引的算法（比如NeighborIndex)。  

## 使用监听器来减少耦合  
比如说，NeighborIndex使用了一个监听器来监听索引化图的修改。通过这种方式来保存增量邻居顶点集合，而不用从外部直接引用图中的继有属性产生耦合。  
